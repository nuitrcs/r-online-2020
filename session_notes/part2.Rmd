---
title: "Part 2: Data Frames"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

# Data Frames

We're going to work with data on penguins from https://github.com/allisonhorst/palmerpenguins.  It's been packaged into an R package.  We're going to install the remotes package that allows us to install R packages from github repositories.  

You may be asked about updating packages during the installation.  You can skip the updates (just hit Return or enter the value for None).

```{r, installpackages, eval=FALSE}
install.packages("remotes")
remotes::install_github("allisonhorst/palmerpenguins")
```

```{r}
library(palmerpenguins)
```


## Manual Creation

How we could manually create a data frame (very rarely will do this)
```{r, manualdf}
x <- data.frame(month=month.name,
                index=1:12,
                days=c(31,28,31,30,31,30,31,31,30,31,30,31))
x
```

## Data Shape and Names

Use the penguin data
```{r, loaddata}
data("penguins")
penguins
```

What is `penguins`?
```{r}
class(penguins)
```

"tbl_df" is a tibble data frame.  These behave a little bit differently from normal data frames.  You'll see tibbles instead of data frames within the tidyverse set of packages (and those packages that work within that framework).

The biggest difference is that tibbles give you a tibble back when subsetting with [], while data frame sometimes give you a vector.

View the first few rows
```{r}
head(penguins)
```

Or use the viewer:
```{r, eval=FALSE}
View(penguins)
```

Clicking on the name of the data frame in the environment tab will also open the viewer.

Dimensions of the data frame
```{r}
dim(penguins)
```

What will the length of a data frame be?  # of columns
```{r}
length(penguins)
```

This is because it's technically a list of vectors (lists are a different type).  Don't use length with a data frame; use `ncol()` instead:
```{r}
ncol(penguins)
```


```{r}
nrow(penguins)
```

What are the variable names?  The columns
```{r}
names(penguins)
```

Rows have names too
```{r}
rownames(penguins)
```

These were generated by default.  Generally don't use row names

What are the column types?
```{r}
str(penguins)
```

Quick summary of every columns
```{r}
summary(penguins)
```


**EXERCISE** (Run the code above first that creates the `x` data frame): Using the `x` data frame we created above:
* How many rows and columns?
* Names of the variables?

```{r}

```


## Indexing

Select first row
```{r}
penguins[1,]
```


Select first two rows
```{r}
penguins[1:2,]
```


Select first column
```{r}
penguins[,1]
```

This gave us a tibble/data.frame back, but with `x`:
```{r}
x[,1]
```

we get a vector back.  This is one difference between tibbles and regular data frames.

We can select rows and columns at the same time:

```{r}
penguins[1:2, 4:5]
```


**EXERCISE** (using `x` created above): how would we select rows 2 through 5, and columns 1 through 2 from `x`?
```{r}

```

If we want rows or columns that aren't next to each other, you can use a vector.

```{r}
x[c(1, 3), ]
```


Reference columns by name with `$` notation (no quotes on names)
```{r}
names(penguins)
```

```{r}
penguins$species
```
Note that the `$` notation got us a vector back.

```{r}
penguins$bill_length_mm
```

Use names in `[]`: put them in quotes
```{r}
penguins[,"species"]
```

Since we used `[]`, we get a tibble/data.frame back this time
```{r}
penguins[,"bill_length_mm"]
```

Multiple columns by name, need to use a vector of names:
```{r}
penguins[,c("island", "species")]
```

```{r}
penguins[10]
```


**EXERCISE**: Using the `x` data frame we created above:
* Select the days column using `$` notation
* Select the month and days columns by name using `[]`

```{r}

```



## Boolean Selection

If we have a boolean vector (`TRUE` and `FALSE` values) that is the same length as the number of rows or columns, we can use it to select from the data frame as we did with vectors.
```{r}
penguins[penguins$bill_length_mm < 34,]
```

Note the rows of `NA`.

If we don't want the missing rows included:

```{r}
sum(is.na(penguins$bill_length_mm))  # how many missing?
penguins[is.na(penguins$bill_length_mm), ]  # which rows have missing values

# select rows where bill_length_mm is not missing and < 34
penguins[!is.na(penguins$bill_length_mm) & penguins$bill_length_mm < 34,]
```


If I forget the `,` in the `[]`:
```{r, eval=FALSE}
penguins[penguins$bill_length_mm < 34]
```

It tries to index the columns instead, and our vector is too long.

Multiple conditions
```{r}
penguins[penguins$bill_length_mm < 34 & penguins$bill_depth_mm < 16,]
```

```{r}
penguins[penguins$bill_length_mm < 34 | penguins$bill_length_mm > 58,]
```

**EXERCISE** Using `x` created above: select rows from `x` with 31 days.  Remember: `==` for testing for equality.

```{r}

```



## Renaming Columns

Normally we don't need to do this first, but I want to keep the current names to use them later first

```{r}
oldnames <- names(penguins)  # save so we can reset later
```

Then I can change the name of the first variable with:

```{r}
names(penguins)[1] <- "boo"  # change the name of the first column
names(penguins)
```

```{r}
names(penguins) <- c("a", "b", "c", "d", "e", "f", "g")  # change all of the column names
head(penguins)
```

Put the old names back
```{r}
names(penguins) <- oldnames
head(penguins)
```


## Working with Variables

```{r}
max(penguins$bill_length_mm)
```

```{r}
max(penguins$bill_length_mm, na.rm=TRUE)
```

Now to get the observations (rows) for the penguins with that max value:
```{r}
penguins[penguins$bill_length_mm == max(penguins$bill_length_mm, na.rm=TRUE),]
```

Break it out into steps:
```{r}
max_bill_length <- max(penguins$bill_length_mm, na.rm=TRUE)
penguins[penguins$bill_length_mm == max_bill_length,]
```

**EXERCISE** Using `x` created above: select the rows from `x` where `days` is at its minimum value.
```{r}

```

You can also use `which.min()` or `which.max()`  to get the index location of the first value with the minimum or maximum value respectively (if there's more than one you only get one):

```{r}
x[which.min(x$days), ]
```



## Making new variables

We can add new variables to the data frame by naming them with the `$` notation:
```{r}
penguins$bill_length_cm <- penguins$bill_length_mm / 10
names(penguins)
penguins[, c("bill_length_cm", "bill_length_mm")]
```


**EXERCISE** Using `x` created above: make a new variable as part of `x`, called `weeks`, that is the number of days divided by 7

```{r}


```



## Missing values

Any missing values?  Show up in summary() output:
```{r}
summary(penguins)
```

Look at the rows where `body_mass_g` is missing:
```{r}
is.na(penguins$body_mass_g)
penguins[is.na(penguins$body_mass_g),]
```

Remove rows where `body_mass_g` is missing by selecting rows where the value is not missing:
```{r}
penguins[!is.na(penguins$body_mass_g),]
penguins <- penguins[!is.na(penguins$body_mass_g),]
```

Remove by index instead:
```{r}
penguins <- penguins[-1,]  # removes the first row of the data
```

**EXERCISE** Using `x` created above: remove the 2nd row of `x`:
```{r}

```


## Replacing Values

```{r}
table(penguins$species)
```

`species` is a factor; let's un-factor it first so we can change values:

```{r}
penguins$species <- as.character(penguins$species)
```


```{r}
penguins$species[penguins$species == "Gentoo"]  # which observations do we want to replace?

penguins$species[penguins$species == "Gentoo"] <- "gentoo"  # set the value

table(penguins$species)
```

We could re-factor it again if we wanted it to stay a factor:

```{r}
penguins$species <- factor(penguins$species)
```


**EXERCISE** Using `x` created above: replace the `month` value "December" with the value "Dec" instead

```{r}

```



# Sort and Order

We're going to talk about sorting and ordering with a vector first.

```{r}
y <- c(30,60,20,30)
y
```

`sort()` puts the values in order (doesn't change the vector, returns a copy)
```{r}
sort(y)
```

Remember, it didn't change y -- `sort()` returned a copy.

```{r}
y
```


```{r}
sort(y, decreasing=TRUE)
```

```{r}
y
```


`order()` tells you what order to put the elements in to sort them:
```{r}
order(y)
```

You can use the output of `order()` to sort:
```{r}
y[order(y)]
```

`order()` also allows decreasing:
```{r}
y[order(y, decreasing=TRUE)]
```

Why do we care?  Because we need this if we want to sort a data frame.  `sort()` only take a vector -- one column of a data frame.  If we want to sort by one or more columns, we need to use `order()` to figure out what to put the rows in -- because we'd want entire rows re-ordered together.

We can sort a single column by itself
```{r}
sort(penguins$bill_length_mm)
```

But if we want rows re-ordered by the value of bill_length_mm, we need to get the order:
```{r}
order(penguins$bill_length_mm)
```

and then use that to re-order the whole data frame
```{r}
penguins[order(penguins$bill_length_mm), ]
```

`order()` will take multiple vectors (columns):
```{r}
penguins[order(penguins$island,
               penguins$bill_length_mm), ]
```

**EXERCISE**: sort the `penguins` data frame by `flipper_length_mm` decreasing
```{r}

```


# Coming Up

Today you'll work more with data frames.  You'll also learn how to read a csv file into R into a data frame, and go over the parts of an R help page.

There are exercises, but I strongly encourage you to read in one of your own data files and start working with it.  If you don't have a data file, there are some examples linked in the exercises that you could try.

One tip to start: if you get an error message that a file can't be found when you're trying to import it: 

1) Check the spelling of the filename for typos

2) Check your working directory (`getwd()`) and make sure the path to the file is correct and completely specified given what your working directory is.

3) Make sure the file is actually in the folder you think it is.  I recommend copying or moving any downloaded files into the project/directory for this workshop so you know you really have the file.  I've seen some problems on Windows computers in particular before where a .zip file isn't really unzipped - it's just letting you see inside without actually expanding the contents and creating real files.



